\chapter{Deployment of Methods in XNAT}
\section{Concrete Docker Method}


\subsection{Introduction to the Automation Script for the Docker Container Method}
The first method analyzed is the Docker Container. After reviewing the latest updates supported by the XNAT Community, it was confirmed that automating Docker Container deployment in XNAT is feasible.
XNAT's REST API provides functionality to list projects, subjects within those projects, sessions, and scans. It also allows the extraction of patient files, as well as the retrieval of the command ID and wrapper ID.
To summarize all the REST APIs used in the automation script, Table A.1 in the Appendix provides a comprehensive overview of each API and its purpose.

\begin{figure}[H]
    \centering
    \def\svgwidth{0.9\linewidth}
    \input{RESTAPI.pdf_tex}
    \caption{Diagram: illustrates the role of the REST API in the automatization}
    \label{fig:workflow-steps}
\end{figure}


The REST API played a crucial role to develop a automatic workflow in the XNAT platform. The figure 3.1 illustrates the role of the REST API in the automatization.



\subsection{Architecture and organization of the Code}
The automation script mirrors the manual workflow in 14 steps. Each part of the script automates a specific step of the manual process, including containerization, image building, command configuration in XNAT, and container launch.

The purpose of this chapter is to introduce the system in more detail. A Python script is used to combine all the steps into an automated workflow. The libraries used in this work include: \texttt{requests}\footnote{\url{https://www.w3schools.com/python/module_requests.asp} accessed on 10 August 2025}, \texttt{json}\footnote{\url{https://www.w3schools.com/python/python_json.asp} accessed on 10 August 2025}, \texttt{os}\footnote{\url{https://docs.python.org/3/library/os.html} accessed on 10 August 2025}, \texttt{subprocess}\footnote{\url{https://docs.python.org/3/library/subprocess.html} accessed on 10 August 2025}, \texttt{getpass}\footnote{\url{https://docs.python.org/3/library/getpass.html} accessed on 10 August 2025}, \texttt{sys}\footnote{\url{https://docs.python.org/3/library/sys.html} accessed on 10 August 2025}, and \texttt{urllib3}\footnote{\url{https://urllib3.readthedocs.io/en/stable/} accessed on 10 August 2025}.

The Python Requests library is the go-to solution for making \ac{HTTP} requests in Python, thanks to its elegant and intuitive API that simplifies the process of interacting with web services and consuming data in the application.\footnote{\url{https://www.datacamp.com/tutorial/python-subprocess} accessed on 10 August 2025} The Sys module in Python provides access to variables and functions that interact closely with the Python interpreter and runtime environment.

Since a JSON-based command is written, the use of the JSON library was necessary. JSON is a syntax for storing and exchanging data. It is text, written with JavaScript Object Notation.\footnote{W3Schools, Python JSON}
The Python Subprocess module is a tool that allows running other programs or commands from your Python code. Using the Python Subprocess module resembles executing commands directly on the system computer using Python instead of typing them directly into the command prompt. This module makes it easy to automate Python code.\footnote{\url{https://www.datacamp.com/tutorial/python-subprocess} accessed on 10 August 2025}
Getpass() prompts the user for a password without echoing. The getpass module provides a secure way to handle password prompts where programs interact with the users via the terminal.\footnote{\url{https://www.geeksforgeeks.org/python/getpass-and-getuser-in-python-password-without-echo/} accessed on 10 August 2025}

The urllib3 library was used to disable the InsecureRequestWarning, which is normally shown when Requests connects to a site with an unverified SSL certificate. This approach helps keep the output clean and free of unnecessary warnings during the run of the script. Figure 3.2 illustrates all the libraries used in the script.

Currently, the system is running Docker Engine 28.3.0. The Docker Client version in use is 20.10.5+dfsg1, which communicates with the Docker Engine to issue commands and manage images and containers. The XNAT web application is running on version 1.9.1.1, as verified through the web interface.


\begin{figure}[ht]
  \centering
  \def\svgwidth{0.8\linewidth}
  \input{lib.pdf_tex}
  \caption{Schema: Core Libraries for Python Scripting in System Integration}
  \label{fig:diagram-core-libraries}
\end{figure}
 
  \subsection{The Dockerfile}
 
The first function responsible for writing the Dockerfile is called \texttt{def write\_dockerfile}, and it takes three arguments: the target directory for the Dockerfile, the name of the Python script to include, and an optional base Docker image (defaulting to \texttt{python:3.10-slim}, currently the fastest and slimmest image of Docker). The function creates the necessary folder (if it does not already exist), constructs the Dockerfile content, and writes it. The content of the Dockerfile is introduced with string interpolation and contains the base image and several commands such as \texttt{WORKDIR /app} (a working directory) and \texttt{COPY \{script\_filename\} /app/\{script\_filename\}} to copy the user script inside the image. The line \texttt{RUN pip install --no-cache-dir pandas} tells Docker to install the pandas Python library using pip during the build process of the Docker image, which helps reduce the overall image size and avoids unnecessary layers in the build process. The last command of the Dockerfile is \texttt{COPY requirements.txt /app/requirements.txt}, which provides the opportunity for the user to write in a separate text file all the libraries used in the container script, to be installed later during the image build process.


The \texttt{CMD} instruction was removed from the Dockerfile because it caused errors when running the container in XNAT. The issue was due to a conflict between the \texttt{CMD} instruction in the Dockerfile and the JSON command configuration, as both included the \texttt{python3} prefix. This led to a duplicate command execution, which caused the container to fail. By removing \texttt{CMD} from the Dockerfile, the execution logic is now fully controlled by XNAT through the JSON-based command, ensuring a successful launch of the Docker Container.


\lstdefinestyle{allblack}{
  basicstyle=\ttfamily\small\color{black},
  keywordstyle=\color{black},
  commentstyle=\color{black},
  stringstyle=\color{black},
  identifierstyle=\color{black},
  numberstyle=\color{black},
  rulecolor=\color{black},
  showstringspaces=false
}

\lstset{style=allblack}



\lstset{inputpath=en/content}

\lstinputlisting[
  inputencoding=cp1252, 
  language=Python,
  firstline=18,
  lastline=24,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 18--24)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize{ See the corresponding lines on GitHub:\url{ https://github.com/tanaebousfiha/XNAT-implemetation/blob/e3c1a547dc8241c4a24f651549069ee042c62393/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L18-L24}}

%--------------------------------------


The rest of the \texttt{def write\_dockerfile} ensures that the specified directory exists, then creates and writes a Dockerfile to that location. It constructs the full path to the file, writes the generated content into it, and prints a confirmation message.




\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=25,
  lastline=29,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 25--29)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{ https://github.com/tanaebousfiha/XNAT-implemetation/blob/e3c1a547dc8241c4a24f651549069ee042c62393/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L25-L29}







This function ensures that the Dockerfile is written in an appropriate way and secures that all the dependencies are stored in the external requirements text file. It handles all possible cases and avoids the issues of errors and standard input errors.

\subsection{Building, Pushing and Tagging the Image}

XNAT requires Docker Hub for container deployment. Users must log in to Docker Hub and push their tagged, locally built images before launching containers.

The function responsible for this process is \texttt{def build\_docker\_image}, which expects two parameters: the Dockerfile path (dockerfile\_path) and the name of the Docker image to be built (docker\_image\_name). Normally, we build an image in Docker with the command: \texttt{docker build .}


In the automation script, the full tag in the format \texttt{dockerhub\_username/docker\_image\_name} is provided. This ensures that the image is already linked to the correct Docker Hub name space and can be pushed directly after building.


\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=38,
  lastline=46,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 38--46)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{ https://github.com/tanaebousfiha/XNAT-implemetation/blob/e3c1a547dc8241c4a24f651549069ee042c62393/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L38-L46}







Here, \texttt{subprocess.run} invokes the docker build command. The option \texttt{ -f dockerfile\_path} specifies which Dockerfile to use, while \texttt{-t full\_tag} sets the name and tag of the image. The final dot (.) indicates that the current directory will be used as the build context.
Once the image is built, it must be pushed to Docker Hub. This is done with the following block:
\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=48,
  lastline=55,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 48--55)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{ https://github.com/tanaebousfiha/XNAT-implemetation/blob/e3c1a547dc8241c4a24f651549069ee042c62393/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L48-L55}





In a manual workflow, the push would be performed with the command:  \texttt{docker push image\_name}. This assumes that the user is already logged in. In the script, the same command is executed through  \texttt{subprocess.run}.

The key point is that the full image tag is constructed in the required Docker Hub format \texttt{(dockerhub\_username/docker\_image\_name)}. This guarantees that the built image is correctly associated with the user’s Docker Hub account, and that XNAT will be able to locate it when launching the container.

\subsection{The Prompt Function for the Required Input}

This function captures various user inputs required by the script. These include the Docker Hub username, command details for JSON configuration, and login credentials.
The function looks like this:
 
\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=59,
  lastline=65,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 59--65)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{ https://github.com/tanaebousfiha/XNAT-implemetation/blob/e3c1a547dc8241c4a24f651549069ee042c62393/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L59-L65}


The \texttt{def get\_input} function uses a \texttt{while True} loop to keep asking until the user enters input. The \texttt{value.strip()} removes any whitespace from the user input. If the input is valid, the value is returned; if not, the message \texttt{Cannot be empty} will be printed.

\subsection{The Command Definition in JSON format}

To communicate the Docker image to XNAT, and consequently to run the container in the website, it is necessary to write a command definition in JSON format.\footnote{\url{ https://wiki.xnat.org/container-service/json-command-definition}}
Typically, JSON command definitions are customized to the image's specific purpose. However, in this automation, the JSON command is generalized to handle any file input.

To achieve that, the function used is called \texttt{create\_json\_file}, which builds the configuration dictionary for a Docker-based XNAT command (for the XNAT Container Service), writes it to a \texttt{command.json} file, and returns the filename.

The function expects three parameters:

\texttt{docker\_image}: The Docker image to use (string).

\texttt{script\_filename}: The name of the Python script inside the container (string).

\texttt{mod\_data}: A dictionary holding user-provided metadata (names, descriptions, etc.).

Let us start analyzing the first block of the JSON command:



\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=120,
  lastline=131,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 120--131)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{ https://github.com/tanaebousfiha/XNAT-implemetation/blob/e3c1a547dc8241c4a24f651549069ee042c62393/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L120-L131}



In this block, we are defining the name of the command, adding a description, and specifying the version and the type of the image.
The command line declares the actual command to run inside the container when invoked by XNAT. The placeholder \# is a template substitution (not a regex expression) that tells XNAT: \texttt{"When you launch the Docker command, replace \#input\_file\# with the actual file name/path that the user selected as input."} It does not define what a valid file looks like; instead, it marks a spot in the command where XNAT should "fill in" an actual value.


The mount configures the directory mappings (as Docker volumes) between XNAT and the Docker container. Most of the time, two are used: the input and the output.
We specified the path \texttt{/input} in the container and indicated whether the container can only read the files (\texttt{Not writable}) or can also write them (\texttt{Writable}).

The second part of command definition in JSON format:


\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=132,
  lastline=160,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 132--150)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub: \url{ https://github.com/tanaebousfiha/XNAT-implemetation/blob/e3c1a547dc8241c4a24f651549069ee042c62393/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L132-L150}


This block defines the parameters that a user must provide as an input file when launching the container.
Let’s break down each field:

The \texttt{"name": "input\_files"} is used in other parts of the JSON as a reference---such as placeholders in the command line. In addition, we add an optional human-friendly description. The \texttt{"type"} indicates that the input accepts more than just text files, scans, or numbers; it specifies that each element in the input is specifically a file through the \texttt{"element"} field.

The \texttt{"required": true} flag means that if the input is not provided, the command cannot be run. The mount in this part links the input to a specific mount inside the container. All files provided by the user will appear in the \texttt{/input} directory inside the container. With \texttt{"multiple": true}, it is indicated that the user can upload or select more than one file for this input.

The same logic applies to the output part. The only additional point to note is the \texttt{"path": "."}, which means the output file will be placed at the top level of the \texttt{/output} directory. To allow more than one output file, the setting \texttt{"type": "files"} is used in the output block.

The final block in the command definition (JSON format):


\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=152,
  lastline=173,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 152--173)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{ https://github.com/tanaebousfiha/XNAT-implemetation/blob/c95b34d9d5a4b236f9b482e02258094384623892/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L152-L173}




This block configures the command's appearance, permissions, data connections, and input handling within XNAT.

The wrapper name is the technical name of the command inside XNAT. The \texttt{"label": mod\_data["label\_name"]} is a human-readable name shown in the XNAT \ac{UI}. The \texttt{"description": mod\_data["label\_description"]} is a description for the tool/wrapper, shown when users browse tools in XNAT. The \texttt{"context"} specifies where we want the container to appear in the XNAT interface. Since the main idea was to have one container on top of the structure of XNAT, here \texttt{["xnat:projectData"]} means this command is available at the project level.


In the \texttt{"external-input"} block, external entities from XNAT are defined. Because we used the project as the context for the command, we require in the external input that a project be selected. In more detail, the name and type must be "Project." This input must be provided, which is why \texttt{"required": true} is specified. We tell XNAT with \texttt{"load-children": true} to load (in the UI) the child objects of the project when showing this input.

In the \texttt{"output-handlers"} block, we control how the outputs from the command are stored and shown in XNAT after job completion. This output handler tells XNAT to take the result file produced by the command, store it as a resource under the project, and call that section ``Results'' in the UI. The \texttt{"as-a-child-of": "project"} specifies that the results are uploaded back into the XNAT project as new resources.

Finally, the script writes the command definition in JSON format, ensuring that the JSON command is saved in the correct format, ready to be uploaded to XNAT.

\subsection{Upload the Command in XNAT}

After writing the JSON-based command, the next step is to send it to XNAT. To achieve this, we have to use the appropriate REST API responsible for uploading the container command to XNAT.
We can find the list of all REST APIs under \texttt{Administer $\rightarrow$ Site Administration $\rightarrow$ Miscellaneous $\rightarrow$ Development Utilities $\rightarrow$ Swagger}.
To send the command to XNAT, we found that the responsible REST API is \texttt{POST}.\footnote{\url{https://xnat-dev.gwdg.de/xapi/swagger-ui.html\#/command-rest-api}}

The function responsible for this is \texttt{def send\_json\_to\_xnat}, and it expects four parameters: \texttt{json\_file\_path, xnat\_url, xnat\_user, xnat\_password}. When working with REST APIs, we first have to build the URL endpoint for XNAT’s command registration.
 
\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=187,
  lastline=200,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 187--200)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{ https://github.com/tanaebousfiha/XNAT-implemetation/blob/c95b34d9d5a4b236f9b482e02258094384623892/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L187-L200}

This function registers a JSON command with XNAT. It constructs the REST API endpoint, loads the JSON data, sends it via a POST request with HTTP Basic Authentication, and provides feedback on the server's response.

\subsection{Preparations to Launch the Container}

To prepare for launching the container in XNAT, the script automatically retrieves the Command ID and Wrapper ID from the XNAT web service using REST APIs.
Option 3 (Concise and direct): Before launching the container, the script automatically retrieves the Command ID and Wrapper ID from XNAT using REST APIs.
\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=204,
  lastline=228,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 204--228)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{ https://github.com/tanaebousfiha/XNAT-implemetation/blob/a47cafecee7f9e467356ddb9f7939371e3d02e03/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L204-L228}



This function retrieves the Command ID and Wrapper ID from XNAT, using the hostname, credentials, command name, and wrapper name as inputs. It constructs the REST API endpoint, checks for a successful response, and returns the IDs. If a wrapper name is provided, it searches for a matching wrapper ID. Following ID retrieval, the enable\_wrapper\_sitewide and enable\_wrapper\_for\_project functions enable the command, using a PUT request to the appropriate XNAT REST API endpoint and providing user feedback.

\subsection{The Extraction of All Files from All Project Structures}

The get\_all\_files\_all\_levels function comprehensively collects all files from an XNAT project's data hierarchy (project, subjects, experiments, scans) using the XNAT REST API (GET). It structures the file information into a dictionary containing the file's level, IDs, name, resource folder, and URI for easy retrieval.

\begin{figure}[ht]
    \centering
    \def\svgwidth{0.9\linewidth}
    \input{extraction.pdf_tex}
    \caption{Diagram: The Extraction of files from all the project structure}
    \label{fig:enter-label}
\end{figure}

\subsection{Launch the Container}

The launch\_container\_with\_all\_files function launches a container with extracted files, using XNAT connection details, project/command identifiers, authentication, wrapper name, and the list of files. It creates a payload, constructs the launch URL, sends a POST request with the payload, and reports the status.


\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=359,
  lastline=393,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 359--393)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{ https://github.com/tanaebousfiha/XNAT-implemetation/blob/3a565f4b666a5f2938d5a41002049ee87cd33b61/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L359-L393}




Figure 3.3 illustrates the steps to deploy a Docker Container in XNAT.


\begin{figure}[ht]
    \centering
    \def\svgwidth{0.9\linewidth}
    \input{steps.pdf_tex}
    \caption{Diagram: Workflow Steps for the Docker Container Deployment in XNAT}
    \label{fig:workflow-steps}
\end{figure}


The \autoref{fig:automatic/manuall} illustrates how the automation script facilitates the process of deploying a container in XNAT. It reduces all the steps.

\begin{figure}[ht]
    \centering
    \def\svgwidth{0.9\linewidth}
    \input{compare.pdf_tex}
    \caption{Diagram: Diagram illustrating the difference between the manual and the automatic process}
    \label{fig:automatic/manuall}
\end{figure}



\subsection{Testing the Code}
Initially, the script requests user input for login credentials, Project ID, command name, and description. Following this input, the script automates image building, tagging, pushing, JSON command creation, command enabling, and container launching.

\subsection{Results on XNAT}
The result that we came to after testing the code is that all the steps are working correctly, except that the container could not receive any files. With the \ac{Stdout} view we found out that the container received zero files. 
 
\begin{lstlisting}[numbers=none]
View stdout (from file)
Inhalt von /input (rekursiv):
/input: []
Keine CSV-Datei in /input gefunden.
\end{lstlisting}


But interestingly, after searching in the container information, we noticed that the container in fact received the files and that the files are listed in the input part of the container input. 
Details of the test procedure are described in Appendix 
\ref{app:Result}. Due to the fact that the list of files was extremely long, it was shortened. In summary, the container received a huge amount of files.

\subsection{Discussion of the results}
This chapter outlines implementation challenges, including data transmission failures, REST API inconsistencies, and JSON configuration mismatches. Initial tests revealed the container wasn't receiving input files, confirmed by a "no\_file.txt" test. Further testing with REST API integration within the container also failed to produce file results in XNAT. Adjustments to the JSON command, including credentials and detailed output specifications, were unsuccessful. Adding delays between container executions also didn't resolve the input file issue.








\subsection{The Workflow Data in XNAT}

When running a container manually in XNAT, data is automatically provided, processed, and results are reloaded. The system first generates a JSON specification with script details, inputs, and outputs. XNAT then prepares the relevant data, copies it to a temporary host directory, and mounts it for container access. The container processes the input, produces results, and writes them back to the host.

While containers can handle many files (with limits adjustable via ulimit), this approach exposes a key issue: containers lack direct access to the XNAT database. Instead, data copying and mounting may cause host memory or disk space problems, especially with large datasets. In testing, failures occurred even with small datasets, suggesting the issue is not only due to size or resource limits.
The diagram below illustrates the workflow data for a clearer understanding.  
\begin{figure}[ht]
    \centering
    \def\svgwidth{\linewidth} 
    \input{xnat.pdf_tex}
    \caption{Diagram: XNAT Workflow for Container Integration}
    \label{fig:workflowxnat}
\end{figure}






\subsection{User Guide}
To better understand the system created and mostly the motivation behind this automation project. We have inserted a table to list how the the Workflow is working and what are the requirement that the user needs to have in order to run the script.

\begin{table}[H]
  \centering
  \caption{System Requirements and Script Details for Automatic Containerization}
  \label{tab:automatic_script}
  \begin{tabular}{|l|p{9cm}|}
  \hline
  \textbf{System Requirements} & 
  - Python installed \newline
  - \texttt{requirements.txt} in the same folder as \texttt{automat\_f\_2.py} \newline
  - XNAT server accessible \newline
  - Docker Engine installed and running \newline
  - Logged in to Docker Hub \\  \hline
  \textbf{Steps to Follow} & 
  1. Run the \texttt{automat\_f\_2.py} script \newline
  2. Enter the prompted inputs \newline
  3. Wait until the container is launched \\
  \hline
  \textbf{What Happens Automatically} & 
  - Dockerfile is generated \newline
  - Docker image is built, tagged, and pushed \newline
  - Command JSON is generated \newline
  - Command is uploaded to XNAT \newline
  - Wrapper is activated site-wide and project-wide \newline
  - Container is launched via REST API \\
  \hline
  \textbf{Problems / Troubleshooting} & 
  - Push failed: check Docker Hub login \newline
  - Wrapper not found or JSON upload failed: check chosen command naming \newline
  - Command already exists: delete old command manually \newline
  - Container problem uploading files: try running \texttt{ls -al \*} on your output directory and check the container \texttt{stdout} log \\
  \hline
  \end{tabular}
\end{table}




