\chapter{Deployment of methods in XNAT}
\section{The Docker method}
This chapter provides an explanation of the Docker Container approach and the deployment of a script for automated container creation and execution at XNAT.

\subsection{Introduction to the automation script for the Docker container method}
Generally, these are the following steps to deploy a Docker container in XNAT manually: writing an external script, building the image and pushing it to Docker Hub, following with writing a appropriate JSON command and deploying it in XNAT server then enabling the command side wide and project wide then finally launching the Docker container. 
After reviewing the latest updates supported by the XNAT Community, it was confirmed that automating Docker container deployment in XNAT is feasible.
XNAT's REST API provides functionality to list projects, subjects within those projects, sessions, and scans. It also allows the extraction of patient files, as well as the retrieval of the command \ac{ID} and wrapper \ac{ID}.
\begin{figure}[H]
    \centering
    \def\svgwidth{0.4\linewidth}
    \input{RESTAPI.pdf_tex}
    \caption{ Diagram: Illustrates the role of the REST API in automation process.}
    \label{fig:RESTAPI}
\end{figure}

To summarize all the REST APIs used in the automation script, Table A.1 in the Appendix provides a comprehensive overview of each API and its purpose.
The \autoref{fig:RESTAPI} illustrates the role of the REST API in the automatization.
\subsection{Architecture and organization of the code}
The automation script mirrors the manual workflow in 14 steps. Each part of the script automates a specific step of the manual process.  
The Python Requests~\cite{request} library is the go-to solution for making \ac{HTTP} requests in Python. The Sys module~\cite{sys} in Python provides access to variables and functions that interact closely with the Python interpreter and runtime environment.
Since a JSON-based command is written, the use of the JSON library~\cite{pythonjson} was necessary. Using the Python Subprocess~\cite{subprocess} module resembles executing commands directly on the system computer using Python. The os library enables the use of operating system dependent functionality~\cite{os}.   
The getpass module provides a secure way to handle password prompts where programs interact with the users via the terminal~\cite{getpass}. 

The urllib3~\cite{urllib3} library was used to disable the Insecure Request Warning, which is normally shown when Requests connects to a site with an unverified SSL certificate. The \autoref{fig:diagram-core-libraries} illustrates all the libraries used in the script.
The system runs Docker Engine 28.3.0, using Docker Client 20.10.5+dfsg1 for management. The XNAT web application is running version 1.9.1.1.

\begin{figure}[H]
  \centering
  \def\svgwidth{0.4\linewidth}
  \input{lib.pdf_tex}
  \caption{Schema: Core Libraries for Python
  scripting in system integration.}
  \label{fig:diagram-core-libraries}
\end{figure}
 
  \subsection{Dockerfile}
 
The first function responsible for writing the Dockerfile is called \texttt{def write\_dockerfile}, and it takes three arguments: the target directory for the Dockerfile, the name of the Python script to include, and an optional base Docker image (defaulting to \texttt{python:3.10-slim}~\cite{Dockerbaseimage}). The function creates the necessary folder (if it does not already exist), constructs the Dockerfile content, and writes it. The content of the Dockerfile is introduced with string interpolation and contains the base image and several commands such as \texttt{WORKDIR /app} (a working directory) and \texttt{COPY \{script\_filename\} /app/\{script\_filename\}} to copy the user script inside the image. The line \texttt{RUN pip install --no-cache-dir pandas} tells Docker to install the pandas Python library using pip during the build process of the Docker image, which helps reduce the overall image size and avoids unnecessary layers in the build process. The last command of the Dockerfile is \texttt{COPY requirements.txt /app/requirements.txt}, which provides the opportunity for the user to write in a separate text file all the libraries used in the container script, to be installed later during the image build process.



\lstdefinestyle{allblack}{
  basicstyle=\ttfamily\small\color{black},
  keywordstyle=\color{black},
  commentstyle=\color{black},
  stringstyle=\color{black},
  identifierstyle=\color{black},
  numberstyle=\color{black},
  rulecolor=\color{black},
  showstringspaces=false
}

\lstset{style=allblack}


\normalsize
\lstset{inputpath=en/content}

\lstinputlisting[
  inputencoding=cp1252, 
  language=Python,
  firstline=16,
  lastline=20,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 16--20)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize{ See the corresponding lines on GitHub:\url{https://github.com/tanaebousfiha/XNAT-implemetation/blob/a399e52da1d7806090dfa230a760009a125d6e0f/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L16-L20}}

\normalsize


The rest of the function creates and writes the Dockerfile to the specified directory, confirming successful completion.

\subsection{Building, pushing and tagging the image}

XNAT requires Docker Hub for container deployment. Users must have Docker Hub account. 

\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=35,
  lastline=46,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 35--46)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{https://github.com/tanaebousfiha/XNAT-implemetation/blob/a399e52da1d7806090dfa230a760009a125d6e0f/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L35-L46}
\normalsize
\\
The function in the Listing 3.3 builds and pushes a Docker image to Docker Hub. It first prompts the user to enter their Docker Hub username and, if provided, constructs a full image tag in the format <username>/<image\_name>. it uses the \texttt{subprocess} module to run a Docker build command with the specified Dockerfile, capturing any output or errors. If the build fails, the script exits with an error message, otherwise, it proceeds to push the built image to Docker Hub using another docker push command. After a successful push, the function prints a confirmation message and returns the full image tag.



\subsection{The prompt function for the required input}

This function captures various user inputs required by the script. These include the Docker Hub username, command details for JSON configuration, and login credentials.
The function looks like this:
 
\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=54,
  lastline=58,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 54--58)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{https://github.com/tanaebousfiha/XNAT-implemetation/blob/a399e52da1d7806090dfa230a760009a125d6e0f/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L54-L58}
\normalsize

The \texttt{def get\_input} function uses a \texttt{while True} loop to keep asking until the user enters input.

\subsection{The command definition in JSON format}

To communicate the Docker image to XNAT, it is necessary to write a command definition in JSON format~\cite{JSONCommand}.
To achieve that, the function used is called \texttt{create\_json\_file}, which builds the configuration dictionary for a Docker-based XNAT command (for the XNAT container service), writes it to a \texttt{command.json} file, and returns the filename.
The first block of the JSON command:



\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=67,
  lastline=75,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 67--75)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{https://github.com/tanaebousfiha/XNAT-implemetation/blob/a399e52da1d7806090dfa230a760009a125d6e0f/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L67-L75}
\normalsize


In this block, the name of the command is defined, adding a description, and specifying the version and the type of the image.
The command-line runs the Python script located at /app/{script\_filename}, passing /input/output as an argument.

The mount configures the directory mappings (as Docker volumes) between XNAT and the Docker container. Most of the time, two are used: the input and the output.
I specified the path \texttt{/input} in the container and indicated whether the container can only read the files (\texttt{Not writable}) or can also write them (\texttt{Writable}).

The second part of command definition in JSON format:


\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=77,
  lastline=93,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 77--93)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub: \url{https://github.com/tanaebousfiha/XNAT-implemetation/blob/a399e52da1d7806090dfa230a760009a125d6e0f/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L77-L93}
\normalsize

This block defines the parameters that a user must provide as an input file when launching the container.
Let’s break down each field:

The \texttt{"name": "input\_files"} is used in other parts of the JSON as a reference such as placeholders in the command line. In addition, we add an optional human-friendly description. The \texttt{"type"} indicates that the input accepts more than just text files, scans, or numbers.

The \texttt{"required": true} flag means that if the input is not provided, the command cannot be run. The mount in this part links the input to a specific mount inside the container. All files provided by the user will appear in the \texttt{/input} directory inside the container. With \texttt{"multiple": true}, it is indicated that the user can upload or select more than one file for this input.
The final block in the command definition (JSON format):


\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=98,
  lastline=117,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 98--117)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{https://github.com/tanaebousfiha/XNAT-implemetation/blob/a399e52da1d7806090dfa230a760009a125d6e0f/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L98-L117}
\normalsize

The wrapper name is the technical name of the command inside XNAT. The \texttt{"label": mod\_data["label\_name"]} is a human-readable name shown in the XNAT \ac{UI}. The \texttt{"description": mod\_data["label\_description"]} is a description for the tool/wrapper, shown when users browse tools in XNAT. The \texttt{"context"} specifies where we want the container to appear in the XNAT interface. Since the main idea was to have one container on top of the structure of XNAT, here \texttt{["xnat:projectData"]} means this command is available at the project level.


In the \texttt{"external-input"} block, external entities from XNAT are defined. Because we used the project as the context for the command, we require in the external input that a project be selected. In more detail, the name and type must be "Project." This input must be provided, which is why \texttt{"required": true} is specified. We tell XNAT with \texttt{"load-children": False} to avoid loading the child objects of the project when showing this input.

In the \texttt{"output-handlers"} block, we control how the outputs from the command are stored and shown in XNAT after job completion. This output handler tells XNAT to take the result file produced by the command, store it as a resource under the project, and call that section ``Results'' in the UI. The \texttt{"as-a-child-of": "project"} specifies that the results are uploaded back into the XNAT project as new resources.
\normalsize
Finally, the script writes the command definition in JSON format, ensuring that the JSON command is saved in the correct format, ready to be uploaded to XNAT.

\subsection{Upload the command in XNAT}

After writing the JSON-based command, the next step is to send it to XNAT. To achieve this, we have to use the appropriate REST API responsible for uploading the container command to XNAT.
We can find the list of all REST APIs under \texttt{Administer $\rightarrow$ Site Administration $\rightarrow$ Miscellaneous $\rightarrow$ Development Utilities $\rightarrow$ Swagger}.
To send the command to XNAT, we found that the responsible REST API is \texttt{POST}~\cite{ContainerRESTAPILIST}.

The function responsible for this is \texttt{def send\_json\_to\_xnat}, and it expects four parameters: \texttt{json\_file\_path, xnat\_url, xnat\_user, xnat\_password}. When working with REST APIs, we first have to build the URL endpoint for XNAT’s command registration.
 
\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=134,
  lastline=137,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 134--137)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{https://github.com/tanaebousfiha/XNAT-implemetation/blob/a399e52da1d7806090dfa230a760009a125d6e0f/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L134-L137}
\normalsize

This function registers a JSON command with XNAT. It constructs the REST API endpoint, loads the JSON data, sends it via a POST request with HTTP Basic authentication, and provides feedback on the server's response.

\subsection{Preparations to launch the container}

To prepare for launching the container in XNAT, the script automatically retrieves the command ID and wrapper ID from the XNAT web service using REST APIs.
\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=149,
  lastline=169,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 149--169)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{https://github.com/tanaebousfiha/XNAT-implemetation/blob/a399e52da1d7806090dfa230a760009a125d6e0f/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L149-L169}
\normalsize


This function retrieves the command ID and wrapper ID from XNAT, using the hostname, credentials, command name, and wrapper name as inputs. It constructs the REST API endpoint, checks for a successful response, and returns the IDs. If a wrapper name is provided, it searches for a matching wrapper ID. Following ID retrieval, the enable\_wrapper\_sitewide and enable\_wrapper\_for\_project functions enable the command, using a PUT request to the appropriate XNAT REST API endpoint and providing user feedback.

\subsection{The Extraction of all files from all project levels}
This step can be optional if in the json command the input and the mount are extend defined (see the permanent link: \url{https://github.com/tanaebousfiha/XNAT-implemetation/blob/4108c0602944bdda25da6324604b80af20a8a397/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L67-L120}
\normalsize
\\
If we define the mount and the input is no need for additional REST API calls.
For the experiment I extracted all the files via REST API calls.
The \autoref{fig:extraction} illustrates all the extraction of all the files from a project structure in XNAT.


\begin{figure}[H]
    \centering
    \def\svgwidth{0.7\linewidth}
    \input{extraction.pdf_tex}
    \caption{Diagram: The extraction of files from the entire project structure.}
    \label{fig:extraction}
\end{figure}

\subsection{Launch the container}

The launch\_container\_with\_all\_files function launches a container with extracted files, using XNAT connection details, project/command identifiers, authentication, wrapper name, and the list of files. It creates a payload, constructs the launch URL, sends a POST request with the payload, and reports the status.

\lstinputlisting[
  inputencoding=cp1252,  language=Python,
  firstline=296,
  lastline=312,
  caption={Extracted from \texttt{automat\_f\_2.py} (lines 296--312)},
  label={lst:automat-snippet}
]{automat_f_2.py}

\noindent\footnotesize See the corresponding lines on GitHub:\url{https://github.com/tanaebousfiha/XNAT-implemetation/blob/a399e52da1d7806090dfa230a760009a125d6e0f/Automation%20of%20the%20manuall%20Process%20of%20the%20xnat%20implementation/automat_f_2.py#L296-L312}
\normalsize


The \autoref{fig:automatic/manuall} illustrates how the automation script facilitates the process of deploying a container in XNAT. It reduces all the steps.

\begin{figure}[H]
    \centering
    \def\svgwidth{0.8\linewidth}
    \input{compare1.pdf_tex}
    \caption{Diagram: The difference between the manual and the automatic process.}
    \label{fig:automatic/manuall}
\end{figure}



\subsection{Testing the code}
Initially, the script requests user input for login credentials, project ID, command name, and description. Following this input, the script automates image building, tagging, pushing, JSON based command creation, command enabling, and container launching.

\subsection{Results on XNAT}
The result that we came to after testing the code is that all the steps are automated correctly, except that the container could not receive any files. With the \ac{Stdout} view we found out that the container received zero files. The Docker container output is shown in the \autoref{lst:stdout}.
 
\begin{lstlisting}[numbers=none, caption={stdout in XNAT.}, label={lst:stdout}]
View stdout (from file)
Inhalt von /input (rekursiv):
/input: []
Keine CSV-Datei in /input gefunden.
\end{lstlisting}


\normalsize
But interestingly, after searching in the container information, we noticed that the container in fact received the files and that the files are listed in the input part of the container input. 
Details of the test procedure are described in Appendix 
\autoref{app:Result}. Due to the fact that the list of files was extremely long, it was shortened. In summary, the container couldn't receive any file.
\normalsize
\subsection{Deployment challenges}
 In this part the deployment challenges are outlined. Initial tests revealed the container wasn't receiving input files, confirmed by a "no\_file.txt" test. Further testing with REST API integration within the Docker container also failed to produce file results in XNAT. Adjustments to the JSON command, including credentials and detailed output specifications, were unsuccessful. Adding delays between container executions also didn't resolve the input file issue.
To circumvent issues with file extraction via REST API calls, the input and mount parameters in the JSON command were modified to include all necessary files. Despite this adjustment, the container failed to receive output files. Subsequently, the container launch method was altered from a string to a URL, yet the file reception issue persisted. As an alternative approach, REST API calls were removed, and an external script using \ac{Pyxnat}~\cite{pyxnat} was developed to extract and supply all files to the container. However, this strategy was also unsuccessful. In summary, XNAT failed to mount any files  from other project level to the container.

Two deployment strategies were tested. Passing all project files to a single Docker container failed due to file transfer issues. Deploying individual containers per project, each processing only local files, was successful, though it resulted in multiple container instances. Chapter 4 provides a detailed discussion of these deployment challenges. 


\normalsize



\subsection{User Guide for Docker automation}
To better understand the system created, a user guide was inserted \autoref{tab:automatic_script} to list how the workflow is working and what are the requirement that the user needs to have in order to run the script. 

\begin{table}[H]
  \centering
  \caption{ User Guide for automation Docker container script.}
  \label{tab:automatic_script}
  \begin{tabular}{|l|p{9cm}|}
  \hline
  \textbf{System Requirements} & 
  - Python installed. \newline
  -\texttt{requirements.txt} in the same folder as \texttt{automat\_f\_2.py}. \newline
  - XNAT server accessible. \newline
  - Docker Engine installed and running. \newline
  - Logged in to Docker Hub. \\  \hline
  \textbf{Steps to Follow} & 
  1. Run the \texttt{automat\_f\_2.py} script. \newline
  2. Enter the prompted inputs. \newline
  3. Wait until the container is launched. \\
  \hline
  \textbf{What Happens Automatically} & 
  - Dockerfile is generated. \newline
  - Docker image is built, tagged, and pushed. \newline
  - Command JSON is generated. \newline
  - Command is uploaded to XNAT. \newline
  - Wrapper is activated site-wide and project-wide. \newline
  - Container is launched via REST API. \\
  \hline
  \textbf{Problems / Troubleshooting} & 
  $\bullet$ Push failed: check Docker Hub login. \newline
  $\bullet$ Wrapper not found or JSON upload failed: check chosen command naming. \newline
  $\bullet$ Command already exists: delete old command manually. \newline
  $\bullet$ Container problem uploading files: check if the transfer was successful by running \texttt{ls -al \*} on your output directory and check the container \texttt{stdout} log. \\
  \hline
  \end{tabular}
\end{table}


\normalsize
