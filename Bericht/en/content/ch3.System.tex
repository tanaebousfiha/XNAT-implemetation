

\chapter{Implementation}

The purpose of this chapter is to introduce the system in more detail. A Python script is used to combine all the steps into an automated workflow. The libraries used in this work include: \texttt{requests}\footnote{\url{https://www.w3schools.com/python/module_requests.asp} accessed on 10 August 2025}, \texttt{json}\footnote{\url{https://www.w3schools.com/python/python_json.asp} accessed on 10 August 2025}, \texttt{os}\footnote{\url{https://docs.python.org/3/library/os.html} accessed on 10 August 2025}, \texttt{subprocess}\footnote{\url{https://docs.python.org/3/library/subprocess.html} accessed on 10 August 2025}, \texttt{getpass}\footnote{\url{https://docs.python.org/3/library/getpass.html} accessed on 10 August 2025}, \texttt{sys}\footnote{\url{https://docs.python.org/3/library/sys.html} accessed on 10 August 2025}, and \texttt{urllib3}\footnote{\url{https://urllib3.readthedocs.io/en/stable/} accessed on 10 August 2025}.

The use of the requests library was for creating the interaction with the web services of XNAT. The Python Requests library is the go-to solution for making HTTP requests in Python, thanks to its elegant and intuitive API that simplifies the process of interacting with web services and consuming data in the application.\footnote{\url{https://www.datacamp.com/tutorial/python-subprocess} accessed on 10 August 2025} 
The \texttt{sys} module in Python gives programmers access to interpreter-specific variables and functions, allowing interaction with the Python runtime environment.\footnote{Python Software Foundation. \url{https://docs.python.org/3/library/sys.html}, accessed 23 August 2025.}




Since a JSON command is written, the use of the JSON library was necessary. 
JSON (JavaScript Object Notation) is a compact text based
 format used to structure, store, and exchange data between applications.\footnote{W3Schools. Python JSON. Available at: \url{https://www.w3schools.com/python/python_json.asp} (accessed 23 August 2025).}

The Python subprocess module is a tool that allows running other programs or commands from your Python code. Using the Python Subprocess module resembles executing commands directly on the system computer using Python instead of typing them directly into the command prompt. This module makes it easy to automate Python code.\footnote{\url{https://www.datacamp.com/tutorial/python-subprocess} accessed on 10 August 2025}

The \texttt{getpass} module in Python allows users to enter passwords in the terminal without showing the input, therefore ensuring confidentiality.\footnote{International Journal of Research Publication and Reviews, Vol. 2, Issue 8, 2021. Available at: \url{https://ijrpr.com/uploads/V2ISSUE8/IJRPR1011.pdf} (accessed 23 August 2025).}


The urllib3 library was used to disable the InsecureRequestWarning, which is normally shown when Requests connects to a site with an unverified SSL certificate. This approach helps keep the output clean and free of unnecessary warnings during the run of the script.

Currently, the system is running Docker Engine 28.3.0. The Docker Client version in use is 20.10.5+dfsg1, which communicates with the Docker Engine to issue commands and manage images and containers. The XNAT web application is running on version 1.9.1.1, as verified through the web interface. Figure 3.1 shows the core libraries used in the script.


\begin{figure}[ht]
  \centering
  \def\svgwidth{0.8\linewidth}
  \input{lib.pdf_tex}
  \caption{Schema: Core Libraries for Python Scripting in System Integration}
  \label{fig:diagram-core-libraries}
\end{figure}






\section{Architecture and organization of the code}
The automation script is structured into 17 distinct parts, each one responsible for a specific step in the overall workflow.
During the development of the automation script, I closely followed the steps of the manual process, since I had already tested and completed it manually. This included writing a container script, writing a Dockerfile, building the image, writing a JSON command, and enabling the command first on the website and then on the project, with the last step being the launch of the container. I carefully repeated the same steps during the implementation. In other words, every structured part is composed of a function that is responsible for carrying out a step of the manual process.
 
 \section{The Dockerfile}
 
The first function responsible for writing the Dockerfile is called \texttt{def write\_dockerfile}, and it takes three arguments: the target directory for the Dockerfile, the name of the Python script to include, and an optional base Docker image (defaulting to \texttt{python:3.10-slim}, currently the fastest and slimmest image of Docker). The function creates the necessary folder (if it does not already exist), constructs the Dockerfile content, and writes it. The content of the Dockerfile is introduced with string interpolation and contains the base image and several commands such as \texttt{WORKDIR /app} (a working directory) and \texttt{COPY \{script\_filename\} /app/\{script\_filename\}} to copy the user script inside the image. The line \texttt{RUN pip install --no-cache-dir pandas} tells Docker to install the pandas Python library using pip during the build process of the Docker image, which helps reduce the overall image size and avoids unnecessary layers in the build process. The last command of the Dockerfile is \texttt{COPY requirements.txt /app/requirements.txt}, which provides the opportunity for the user to write in a separate text file all the libraries used in the container script, to be installed later during the image build process.


The \texttt{CMD} instruction was removed from the Dockerfile because it caused errors when running the container in XNAT. The issue was due to a conflict between the \texttt{CMD} instruction in the Dockerfile and the JSON command configuration, as both included the \texttt{python3} prefix. This led to a duplicate command execution, which caused the container to fail. By removing \texttt{CMD} from the Dockerfile, the execution logic is now fully controlled by XNAT through the JSON-based command, ensuring a successful launch of the container.


\lstinputlisting{automat_f_2.py}













The rest of the \texttt{def write\_dockerfile} ensures that the specified directory exists, then creates and writes a Dockerfile to that location. It constructs the full path to the file, writes the generated content into it, and prints a confirmation message.


\lstset{
  language=Python,
  basicstyle=\ttfamily\small\color{black},
  keywordstyle=\color{black},
  identifierstyle=\color{black},
  stringstyle=\color{black},
  commentstyle=\color{black},
  numberstyle=\color{black},
  showstringspaces=false
}

\begin{lstlisting}
os.makedirs(docker_dir, exist_ok=True)
dockerfile_path = os.path.join(docker_dir, "Dockerfile")
with open(dockerfile_path, "w") as f:
    f.write(dockerfile_content)
print(f"Dockerfile written to {dockerfile_path}")
return dockerfile_path
\end{lstlisting}

This function ensures that the Dockerfile is written in an appropriate way and secures that all the dependencies are stored in the external requirements text file. It handles all possible cases and avoids the issues of errors and standard input errors.

\section{Building, Pushing and Tagging the Image}

When a command is deployed in XNAT and a container is launched, XNAT first checks whether the required Docker image is available on Docker Hub. This requires the user to have a Docker Hub account and to be logged in before running the script. For this reason, it is essential that the locally built image is correctly tagged and pushed to Docker Hub.

The function responsible for this process is \texttt{def build\_docker\_image}, which expects two parameters: the Dockerfile path (dockerfile\_path) and the name of the Docker image to be built (docker\_image\_name). Normally, we build an image in Docker with the command: \texttt{docker build .}


In the automation script, the full tag in the format \texttt{dockerhub\_username/image\_name:tag} is provided. This ensures that the image is already linked to the correct Docker Hub name space and can be pushed directly after building.
\begin{lstlisting}
full_tag = f"{dockerhub_username}/{docker_image_name}:{tag}"
print(f"Building Docker image '{full_tag}'...")
build_result = subprocess.run(
    ["docker", "build", "-f", dockerfile_path, "-t", full_tag, "."],
    capture_output=True, text=True
)
if build_result.returncode != 0:
    print(f"Build failed:\n{build_result.stderr}")
    sys.exit(1)
print(f"Image '{full_tag}' built successfully.")
\end{lstlisting}

Here, \texttt{subprocess.run} invokes the docker build command. The option \texttt{ -f dockerfile\_path} specifies which Dockerfile to use, while \texttt{-t full\_tag} sets the name and tag of the image. The final dot (.) indicates that the current directory will be used as the build context. The arguments \texttt{capture\_output=True} and text=True ensure that both stdout and stderr are captured and returned as strings, so that the script can handle them properly.

Once the image is built, it must be pushed to Docker Hub. This is done with the following block:
\begin{lstlisting}
push_result = subprocess.run(["docker", "push", full_tag], capture_output=True, text=True)
if push_result.returncode != 0:
    print(f"Push failed:\n{push_result.stderr}")
    sys.exit(1)
print(f"Image successfully pushed: {full_tag}")

\end{lstlisting}
In a manual workflow, the push would be performed with the command:  \texttt{docker push image\_name}. This assumes that the user is already logged in. In the script, the same command is executed through  \texttt{subprocess.run}.

The key point is that the full image tag is constructed in the required Docker Hub format \texttt{(dockerhub\_username/image\_name:tag)}. This guarantees that the built image is correctly associated with the user’s Docker Hub account, and that XNAT will be able to locate it when launching the container.

\section{The Prompt Function for the Required Input}

This function performs the task of capturing input from the user.
We have used this function in the script in multiple scenarios. The first was to take the Docker Hub username from the user. To customize the JSON command, we asked the user for the name of the command and its description. Overall, it is also used to take the username and password from the user’s login credentials. The function proceeds through all of these steps while running the script.

The function looks like this:
 
 \begin{lstlisting}
 def get_input(prompt):
    while True:
        value = input(prompt)
        if value.strip():
            return value
        else:
            print("Cannot be empty.")

\end{lstlisting}
The \texttt{def get\_input} function uses a \texttt{while True} loop to keep asking until the user enters input. The \texttt{value.strip()} removes any whitespace from the user input. If the input is valid, the value is returned; if not, the message \texttt{Cannot be empty} will be printed.

\section{The Command Definition in JSON format}

To communicate the Docker image to XNAT, and consequently to run the container in the website, it is necessary to write a command definition in JSON format.\footnote{\url{https://wiki.xnat.org/container-service/json-command-definition}}
Usually, the JSON-based command definition is personalized and customized depending on the main idea of the image. But in the automation case, the JSON-based command must be generalized for all cases, which means no matter which file is selected, the command will still handle it.

To achieve that, the function used is called \texttt{create\_json\_file}, which builds the configuration dictionary for a Docker-based XNAT command (for the XNAT Container Service), writes it to a \texttt{command.json} file, and returns the filename.

The function expects three parameters:

\texttt{docker\_image}: The Docker image to use (string).

\texttt{script\_filename}: The name of the Python script inside the container (string).

\texttt{mod\_data}: A dictionary holding user-provided metadata (names, descriptions, etc.).

Let us start analyzing the first block of the JSON command:
\begin{lstlisting}

json_file = {
        "name": mod_data["command_name"],
        "description": mod_data["command_description"],
        "version": "1.5",
        "type": "docker",
        "image": docker_image,
        "command-line": f"python3 /app/{script_filename} /input/#input_file# /output",
        "mounts": [
            {"name": "input", "path": "/input", "writable": False},
            {"name": "output", "path": "/output", "writable": True}
        ],
\end{lstlisting}


In this block, we are defining the name of the command, adding a description, and specifying the version and the type of the image.
The command line declares the actual command to run inside the container when invoked by XNAT. The placeholder \# is a template substitution (not a regex expression) that tells XNAT: \texttt{"When you launch the Docker command, replace \#input\_file\# with the actual file name/path that the user selected as input."} It does not define what a valid file looks like; instead, it marks a spot in the command where XNAT should "fill in" an actual value.


The mount configures the directory mappings (as Docker volumes) between XNAT and the Docker container. Most of the time, two are used: the input and the output.
We specified the path \texttt{/input} in the container and indicated whether the container can only read the files (\texttt{Not writable}) or can also write them (\texttt{Writable}).

The second part of command definition in JSON format:


\begin{lstlisting}

 "inputs": [
            {
                "name": "input_files",
                "description": "Input files",
                "type": "files",
                "element_type": "file",
                "required": True,
                "mount": "input",
                "multiple": True
            }
        ],
        "outputs": [
            {
                "name": "result_file",
                "type": "file",
                "description": "Result file output",
                "mount": "output",
                "path": "."
            }
        ],
\end{lstlisting}


This block defines the parameters that a user must provide as an input file when launching the container.
Let’s break down each field:

The \texttt{"name": "input\_files"} is used in other parts of the JSON as a reference---such as placeholders in the command line. In addition, we add an optional human-friendly description. The \texttt{"type"} indicates that the input accepts more than just text files, scans, or numbers; it specifies that each element in the input is specifically a file through the \texttt{"element"} field.

The \texttt{"required": true} flag means that if the input is not provided, the command cannot be run. The mount in this part links the input to a specific mount inside the container. All files provided by the user will appear in the \texttt{/input} directory inside the container. With \texttt{"multiple": true}, it is indicated that the user can upload or select more than one file for this input.

The same logic applies to the output part. The only additional point to note is the \texttt{"path": "."}, which means the output file will be placed at the top level of the \texttt{/output} directory. To allow more than one output file, the setting \texttt{"type": "files"} is used in the output block.

The final block in the command definition (JSON format):

\begin{lstlisting}

 "xnat": [
            {
                "name": wrapper_name,
                "label": mod_data["label_name"],
                "description": mod_data["label_description"],
                "contexts": ["xnat:projectData"],  
                "external-inputs": [
                    { 
                        "name": "project",
                        "type": "Project",
                        "required": True,
                        "load-children": True
                    }
                ],
                "output-handlers": [
                    {
                        "name": "output",
                        "accepts-command-output": "result_file",
                        "as-a-child-of": "project",
                        "type": "Resource",
                        "label": "Results",
                    }
\end{lstlisting}

This block defines what will be displayed on the XNAT interface and connects the Docker command with XNAT's web interface and permission system. It controls how the command appears as a tool in XNAT, how it is integrated with projects or other data, and how inputs are handled.

The wrapper name is the technical name of the command inside XNAT. The \texttt{"label": mod\_data["label\_name"]} is a human-readable name shown in the XNAT \ac{UI}. The \texttt{"description": mod\_data["label\_description"]} is a description for the tool/wrapper, shown when users browse tools in XNAT. The \texttt{"context"} specifies where we want the container to appear in the XNAT interface. Since the main idea was to have one container on top of the structure of XNAT, here \texttt{["xnat:projectData"]} means this command is available at the project level.


In the \texttt{"external-input"} block, external entities from XNAT are defined. Because we used the project as the context for the command, we require in the external input that a project be selected. In more detail, the name and type must be "Project." This input must be provided, which is why \texttt{"required": true} is specified. We tell XNAT with \texttt{"load-children": true} to load (in the UI) the child objects of the project when showing this input.

In the \texttt{"output-handlers"} block, we control how the outputs from the command are stored and shown in XNAT after job completion. This output handler tells XNAT to take the result file produced by the command, store it as a resource under the project, and call that section ``Results'' in the UI. The \texttt{"as-a-child-of": "project"} specifies that the results are uploaded back into the XNAT project as new resources.

Finally, the script writes the command definition in JSON format, ensuring that the JSON command is saved in the correct format, ready to be uploaded to XNAT.

\section{Upload the Command in XNAT}

After writing the JSON-based command, the next step is to send it to XNAT. To achieve this, we have to use the appropriate REST API responsible for uploading the container command to XNAT.
We can find the list of all REST APIs under \texttt{Administer $\rightarrow$ Site Administration $\rightarrow$ Miscellaneous $\rightarrow$ Development Utilities $\rightarrow$ Swagger}.
To send the command to XNAT, we found that the responsible REST API is \texttt{POST}.\footnote{\url{https://xnat-dev.gwdg.de/xapi/swagger-ui.html\#/command-rest-api}}

The function responsible for this is \texttt{def send\_json\_to\_xnat}, and it expects four parameters: \texttt{json\_file\_path, xnat\_url, xnat\_user, xnat\_password}. When working with REST APIs, we first have to build the URL endpoint for XNAT’s command registration.
 
\begin{lstlisting}
def send_json_to_xnat(json_file_path, xnat_url, xnat_user, xnat_password): 

    url = f"{xnat_url}/xapi/commands"
    print(f"Uploading command to {url}")
    with open(json_file_path, "r") as f:
        response = requests.post(url, auth=(xnat_user, xnat_password), json=json.load(f))
    if response.status_code == 200:
        print("Command uploaded successfully.")
    elif response.status_code == 201:
        print("Command created successfully.")
    elif response.status_code == 409:
        print("Command already exists.")
    else:
        print(f"Failed to upload command: {response.status_code} - {response.text}")
\end{lstlisting}

This function takes the path that describes the JSON-based command, the base URL of the XNAT server, and the credentials for authentication. First, it constructs the correct REST API endpoint by appending \texttt{/xapi/commands} to the provided XNAT URL, ensuring that the command is sent to the appropriate API for command registration. It then opens the JSON file, loads its contents, and sends this data as a POST request to the API endpoint using \ac{HTTP} Basic Authentication with the supplied username and password. After making the request, the function examines the server’s response, and in each case provides feedback, helping the user quickly understand whether the command upload succeeded or if further action is needed to resolve an issue.

\section{Preparations to Launch the Container}

The goal of the previous steps is to launch the container in XNAT, but before that we need to perform some preparations. In line with the automation principle, we need to retrieve some information from the XNAT web service, and in this case we use the REST API technique as well. The first information that we need to extract after sending the JSON command to XNAT is the \texttt{Command ID} and the \texttt{Wrapper ID}.
In order to do that...
 
\begin{lstlisting}
def get_command_wrapper_id(xnat_host, xnat_user, xnat_password, command_name, wrapper_name=None):
 
    url = f"{xnat_host.rstrip('/')}/xapi/commands"
    try:
        resp = requests.get(url, auth=(xnat_user, xnat_password), verify=False)
    except Exception as e:
        print(f"Verbindungsfehler: {e}")
        sys.exit(1)
    if resp.status_code != 200:
        print(f"Fehler beim Abrufen der Commands: {resp.status_code}")
        sys.exit(1)
    data = resp.json()
    commands = data.get("commands", data) if isinstance(data, dict) else data

    for command in commands:
        if command.get("name") == command_name:
            if not wrapper_name:
                return command.get("id")
            
            for wrappers_field in ["xnat", "wrappers"]:
                for wrapper in command.get(wrappers_field, []):
                    if wrapper.get("name") == wrapper_name:
                        return wrapper.get("id") or wrapper_name
            print("no Wrapper found")
            sys.exit(1)
    print("Command nicht gefunden.")
    sys.exit(1)
\end{lstlisting}

The function takes as input the XNAT server’s hostname, user password, the name of the desired command, and the name of a specific wrapper. It first builds the correct XNAT REST API endpoint to list all the registered commands on XNAT.
Upon receiving a response, the function checks for a successful status (200 OK); otherwise, it reports the failure and exits. If only a command ID is needed (no wrapper specified), it returns the command’s ID directly. If a wrapper name is provided, the function searches for the wrapper within possible sections of the command definition under XNAT or the \texttt{"wrappers"} fields—returning the wrapper’s ID upon match. If the specified command or wrapper cannot be found, the function clearly reports this to the user.

After receiving the Command ID and the Wrapper ID, we proceed by enabling the command in the project and site-wide. For that, we use the two functions \texttt{def enable\_wrapper\_sitewide} and \texttt{def enable\_wrapper\_for\_project}, which both expect parameters such as the server’s hostname, user login and password, and the extracted Command ID and Wrapper ID. Each function builds the desired XNAT REST API endpoint (in this case, we used the \texttt{PUT} REST API), checks the status of the process, and provides feedback to the user to track the code’s progress.

\section{The Extraction of All Files from All Project Structures}

The function used in this part is \texttt{def get\_all\_files\_all\_levels}, and it collects all the files in the project data hierarchy (project, subjects, experiments/sessions, and scans) from an XNAT system using its REST API. We used the REST API endpoint \texttt{GET} for the extraction. The function proceeds by authenticating with the XNAT server using the provided user credentials and starts by gathering project-level files, querying all resource folders at the project root and listing every file found within them. At every step, the function structures each file into a dictionary containing hierarchical information (such as the level—project, subject, experiment, scan—and the relevant IDs), the file name, the resource folder it was found in, and an absolute URI for straightforward retrieval. By the end, it returns a comprehensive list of all file records across all levels in the project.\footnote{\url{https://wiki.xnat.org/documentation/strategies-for-xnat-image-data-storage}last acced 25.08.2025}. Figure 3.2 explains the hierarchy where the files are stored.

\begin{figure}[ht]
    \centering
    \def\svgwidth{0.9\linewidth}
    \input{extraction.pdf_tex}
    \caption{Diagram: The Extraction of files from all the project structure}
    \label{fig:enter-label}
\end{figure}

\section{Launch the Container}

Arriving at the well-known part of launching the container, we use the function \texttt{def launch\_container\_with\_all\_files}. This function is designed to automatically launch a container with all the files previously extracted as input. It takes the XNAT server connection details, project and command identifiers, user authentication, the wrapper name, and a list of files to be processed.

The function first checks if any files are provided. A payload dictionary is then prepared, mapping the project ID and the input files string to the fields. Next, the function constructs the appropriate URL for launching the command. Before sending the launch request, the function prints diagnostic information, including the chosen files and payload. It then submits a \texttt{POST} request with the payload as JSON and user credentials for authentication. After sending the request, the function reports back to the user about the status and the response.

\begin{lstlisting}
def launch_container_with_all_files(xnat_host, project_id, command_id, wrapper_name, xnat_user, xnat_password, files):
   
    if not files:
        print("no files found.")
        return 

    payload = {
        "project": project_id,
        "input_files": input_files_str
    }

    url = f"{xnat_host}/xapi/projects/{project_id}/commands/{command_id}/wrappers/{wrapper_name}/root/project/launch"

    headers = {"Content-Type": "application/json"}
    response = requests.post(
        url, auth=(xnat_user, xnat_password),
        headers=headers, json=payload, verify=False
    )

    print("Status:", response.status_code)
    print("Antwort:", response.text)
    if response.status_code in [200, 201, 202]:
        print("Container launched with all files!")
    else:
        print("failure :", response.status_code, response.text)
\end{lstlisting}
Figure 3.3 illustrates the steps to implement a container in XNAT.


\begin{figure}[ht]
    \centering
    \def\svgwidth{0.9\linewidth}
    \input{steps.pdf_tex}
    \caption{Diagram: Workflow Steps for the Implementation}
    \label{fig:workflow-steps}
\end{figure}


The figure 3.4 illustrates how the automation script facilitates the process of deploying a container in XNAT. It reduces all the steps.

\begin{figure}[ht]
    \centering
    \def\svgwidth{0.9\linewidth}
    \input{compare.pdf_tex}
    \caption{Diagram: Diagram illustrating the difference between the manual and the automatic process}
    \label{fig:enter-label}
\end{figure}

\begin{comment}
    https://wiki.xnat.org/documentation/strategies-for-xnat-image-data-storage
\end{comment}




